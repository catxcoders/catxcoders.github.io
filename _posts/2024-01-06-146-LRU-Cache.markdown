---
layout: article_post
title:  "[Leetcode解題] 146. LRU Cache"
description:  "[Leetcode解題] 146. LRU Cache"
categories: medium
tags: double-linked-list hashmap
langs: python
excerpt_separator: <!--more-->
---

## 題目

[146. LRU Cache](https://leetcode.com/problems/lru-cache/description/)
設計一個資料結構，符合最近最少使用 (LRU) cache的限制。實作 LRUCache 類別，包含以下方法：

- LRUCache(int capacity)：初始化一個具有正數容量的 LRU cache。
- int get(int key)：如果key存在，返回相對應的value，否則返回 -1。
- void put(int key, int value)：如果key存在，更新相對應的value。否則，將key-value添加到cache中。如果使key的數量超過capacity，則淘汰最近最少使用的key。

> get 和 put 方法的平均時間複雜度應為 O(1)。

<!--more-->


## 解題思路

為了實現 $O(1)$ 的平均時間複雜度，我們可以使用有序字典 (*OrderedDict*) 來儲存cache的內容，以保持**插入順序**。

- `get` 函式：如果 key 存在，將該 key 移動到有序Dictionary的最後，並返回對應的值；否則返回 -1。
- `put` 函式：如果 key 存在，更新其值並將該 key 移動到有序Dictionary的最後；如果 key 不存在，將新的 key-value 對加入cache。若cache大小超過容量，則移除有序Dictionary中的第一個元素（最少使用的元素）。

### OrderedDict介紹
*OrderedDict* 是 Python 中的一個有序 *dictionary* 類別，它在內部實現中使用了*doubly linked list (DLL)* 和 *dictionary*的組合，以保持元素的**插入順序**。

具體來說，*OrderedDict* 的內部實現主要包括兩個方面：

- **Dictionary**：用來存key-value pairs的 hash-table。
這個 hash-table 使用dictionary快速查找，例如根據key查找value。
- **Doubly Linked List**：用來維護插入順序的Linked List結構。
每個節點包含了key、value以及指向前一個節點和後一個節點的pointer。
當一個元素被插入時，它同時被添加到雙向Linked List的tail；當一個元素被訪問時，它被移動到Linked List的tail，這樣最近被訪問的元素總是位於Linked List的tail。

## 實作
```python
class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key in self.cache:
            self.cache.move_to_end(key)
            return self.cache[key]
        return -1

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache[key] = value
            self.cache.move_to_end(key)
        else:
            self.cache[key] = value
            if len(self.cache) > self.capacity:
                self.cache.popitem(last=False) 


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
        
```

## 時間複雜度
`get` 和 `put` 函式的平均時間複雜度為 $O(1)$。由於有序字典 (*OrderedDict*) 保持插入順序，cache的最後一個元素總是最近最少使用的元素，因此這兩個操作的時間複雜度都是 $O(1)$。
